# 2장 리액트 핵심 요소 깊게 살펴보기

## JSX

JSX는 기본적으로 ECMAScript 표준의 일부가 아니며 자바스크립트 엔진에서 동작할 수 없음(이렇게 생긴게 아예 없으니까 당연한 부분인듯..?)

JSX는 페이스북에서 임의로 만든 문법이기 때문에 반드시 트랜스파일러를 거쳐야한다.

JSX는 내부에 트리 구조로 표현하고 싶은 다양한 것들을 작성 후에 트랜스파일링을 통해 자바스크립트가 이해할 수 있는 코드로 변경하는 것. JS에서 표현하기 어려웠던 XML 스타일의 트리 구조의 까다로운 표현을 쉽게 만들어줄 수 있는 문법

### JSX의 정의

JSX는 기본적으로 4가지 컴포넌트를 기반으로 구성되어 있다.

1. JSXElement
    - JSX를 구성하는 가장 기본적인 요소로 HTML 요소와 비슷한 역할을 함
    
    ```jsx
    <JSXElement></JSXElement> // OpeningElement, ClosingElment
    
    <JSXSelfClosingElement /> // SelfClosingElement
    
    <>JSXChildren(optional)</> // JSXFragment
    ```
    - React JSX를 닫아야 하는 이유 : 
        1. JSX는 HTML처럼 보이지만, 내부적으로는 JS 객체로 변환된다. 하나의 배열로 감싸지 않은 하나의 함수에서는 두 개의 객체를 반환 불가능함. 그래서 또 다른 태그나 Fragment로 감싸지 않으면 두 개의 JSX태그를 반환할 수 없다.
        2. `return {a}, {b}` 와 비슷한 형태로 JS에서 구조 분해 할당으로 반환할 수는 있지만 객체나 배열로 감싸줘야 함.
2. JSXAttributes
    - JSX에 부여할 수 있는 속성인 Props를 의미함 
    - 기본적으로 객체로 전달되기 때문에 Spread연산자로 사용될 수 있다
    - `속성의 키 = 값` 의 형태로 작성한다.
        - 값에 할당할 수 있는 값은 다음과 같은 조건 중 하나를 만족해야함
            문자열, 할당식 `() ⇒ { }`, JSX (잘 안씀)
3. JSXChildren
    - JSXElement의 자식 값을 나타내며 트리 구조를 나타내기 위해 만들어졌기 때문에 부모와 자식 관계를 나타낼 수 있음
    - Text, JSXElement, JSXFragment, 할당 식이 들어갈 수 있다
    - 만약 컴포넌트를 중첩하면 부모 컴포넌트에서 { children } prop을 통해 접근 가능
4. JSXString
    - HTML에서 가능한 문자열은 JSX에서도 가능하다.

### JSX가 자바스크립트에서 변환되는 방식

JSX는 **React.createElement**라는 메소드로 객체를 만드는 형태로 트랜스파일링된다.

`createElement(type, props, ...children)` 는 React 엘리먼트를 생성한다.

- React 엘리먼트는 UI의 일부에 대한 축약 정보

```jsx

<Component name = "hi" />

createElement(Component, { name: 'hi' })
```

위 두줄의 코드는 같은 객체 생성

```jsx
{
  type: Component,
  props: {
    name: 'hi'
  },
  key: null,
  ref: null,
}
```

객체를 생성했다고 해서 컴포넌트가 렌더링되거나 DOM 요소가 생성되는 것은 아니고, 객체를 이용해서 컴포넌트 렌더링이 가능하도록 함   
`App` 객체에서 이 객체를 해주는걸로 다음에 수행할 작업을 지시 가능

컴포넌트 구조와 동일한 객체 구조가 생성될것

```jsx
{
  type: App,
  props: { 
   // ...
   children: [//... ReactElements ...]
 },
  key: null,
  ref: null,
}
```

## 가상 DOM과 리액트 파이버

### DOM과 브라우저 렌더링 과정

DOM은 웹페이지에 대한 인터페이스(브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보)

**렌더링의 더 자세한 과정**

1. 브라우저가 요청한 주소를 나눠서 HTML 파일을 다운로드
2. 브라우저의 렌더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리 생성(CSS 파일을 만나게 된다면 CSS 파일을 다운로드 함)
3. 브라우저 렌더링 엔진은 CSS역시 파싱해 CSSOM 트리 생성
4. 브라우저는 DOM 트리를 순회하는데, 여기서 모든 노드를 방문 x, 사용자의 눈에 보이는 노드만 방문한다.
5. 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 정보를 노드에 반영한다.
    - 렌더트리 생성
    - 레이아웃(layout, reflow): 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산
    - 페인팅(painting): 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

### 가상 DOM의 탄생 배경

가상 DOM은 말 그대로 실제 브라우저의 DOM이 아닌 리액트가 관리하는 가상의 DOM을 의미한다. 가상 DOM은 웹페이지가 표시해야 할 DOM을 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저 DOM에 반영한다. DOM 변경사항 계산을 브라우저가 아닌 메모리에서 계산하는 과정을 한 번 거치게 된다면 렌더링을 최소화 할 수 있다. (인터랙션에 따른 DOM의 최종 결과물을 계산한 다음 DOM에 반영하기 때문)

가상 DOM은 브라우저의 DOM 관리 속도를 빠르게 만들 목적으로 고안된것이 아니라 무거운 연산인 DOM을 브라우저에서 실행하지 않고 메모리 공간에서 수행해 변경사항을 한 번에 브라우저에 반영할 수 있게해 연산 부담을 줄이는 것에 있다.

이런 것들을 가능케 하는 것 -> 리액트 파이버

### 가상 DOM을 위한 아키텍처, 리액트 파이버

가상 DOM과 렌더링 과정 최적화(여러 번의 렌더링 과정을 압축해 최소한의 렌더링 단위를 만들어내는 것)를 가능하게 해주는 것이 리액트 파이버(React Fiber)다.

**리액트 파이버란?**

리액트 파이버는 리액트에서 관리하는 평범한 자바스크립트 객체로, 재조정자(fiber reconciler)가 있는데 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하고 차이를 발견하면 변경된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.

- 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
- 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 재사용하거나 필욯지 않은 경우에는 폐기할 수 있다.

(렌더링에 필요한 작업 / 상호작용, AJAX, 애니메이션 등)

> 작업? -> 에니메이션, 레이아웃(reflow), 인터랙션에 올바른 결과물을 만드는 반응

*** 중요한 것은 위 과정은 모두 비동기로 일어남 ***

파이버는 하나의 작업단위로 구성되어 있다. 이 작업 단위를 하나씩 처리하고 finishedWork()라는 작업으로 마무리하고, 이 작업을 커밋해 실제 브라우저 DOM에 가시적인 변경 사항을 만든다.

- 렌더 단계에서 리액트는 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 그리고 이 단계에서 앞서 언급한 파이버의 작업, 우선순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.
- 커밋 단계에서는 앞서 언급한 것처럼 DOM에 실제 변경 사항을 반영하기 위한 작업인 commitWork() 실행(동기식, 중단 불가능)

**파이버 객체의 프로퍼티**

- tag
    - 파이버는 하나의 엘리먼트에 하나가 생성되는 1:1관계를 가지고 있다. 1:1 매칭된 정보를 가지고 있는 것이 tag다.
    - tag 파이버 객체가 어떤 요소로부터 생성되었는지 판단한다. 컴포넌트일 수도 DOM 노드일 수도, 혹은 다른 어떤 것
- stateNode: 파이버 자체에 대한 참조 정보를 가지고 있으며, 이 참조를 바탕으로 리액트는 파이버와 관련된 상태에 접근한다.
- child, sibling, return: 파이버 간의 관계 개념을 나타내는 속성
    - 파이버는 트리 형식을 갖게 되는데, 트리 형식을 구성하는 데 필요한 정보가 이 속성 내부에 정의
    - 하지만 파이버는 children이 없음.
    - 파이버의 첫 번째 자식의 참조가 child, 같은 계층의 자식들은 sibling으로 갖게된다.
    - return은 부모 파이버를 나타낸다.
    
    ```html
    <div> <!-- child ul-->
    	<ul> <!-- child l1, return div, none sibling-->
    		<li></li> <!-- sibling l2, return ul-->
    		<li></li> <!-- sibling l3, return ul -->
    		<li></li> <!-- none sibling, return ul -->
    	</ul>
    </div>
    ```
    
- index: 여러 형제들 사이에엇 자신의 위치가 볓 번째인지 숫자로 표현한다.
- pendingProps: 아직 작업을 미처 처리하지 못한 props
- **memoizedProps: pendingProps를 기준으로 렌더링이 완료된 이후에 pendingProps를 memoizedProps로 저장해 관리한다.**
- **updateQueue: 상태 업데이트, 콜백 함수, DOM 업데이트 등 필요한 작업을 담아두는 큐**
- **memoizedState: 함수형 컴포넌트의 훅 목록이 저장된다. 여기에는 단순히 useState뿐만 아니라 모든 훅 리스트가 저장**
- alternate: 반대편 트리, 비교를 할 트리 파이버를 가리킨다.

생성된 파이버 트리는 상태 변경, 생명주기 메서드 실행, DOM 변경이 필요한 시점 등에 실행된다. 그리고 중요한 것은 리액트가 파이버를 처리할 때마다 이러한 작업을 직접 바로 처리하기도 하고 스케줄링하기도 한다는 것이다. 즉, 이러한 작업들은 작업 단위로 나눠서 처리할 수도, 우선순위가 높은 작업은 가능한 한 빠르게 처리하거나 낮은 작업을 연기시키는 등 좀 더 유연하게 처리된다.

파이버는 사실 값을 가지고 있는 UI를 관리하는 라이브러리다. UI를 값으로 관리한다는 것…!

**리액트 파이버 트리**

파이버 트리는 리액트 내부에 두개가 존재한다. 현재 모습을 담은 파이버 트리, 작업 중인 상태를 나타내는 **workInProgress(뭔가 바뀌고 있는 파이버) 트리다.** 

먼저 현재 UI 렌더링을 위해 존재하는 트리인 **current**를 기준으로 모든 작업이 시작된다. 여기서 만약 업데이트가 발생하면 파이버는 리액트에서 새로 받은 데이터로 새로운 **workInProgress** 트리를 빌드하기 시작한다. 이 트리를 빌드하는 작업이 끝나면 다음 렌더링에 이 트리를 사용한다.

그리고 **Commit(current가 이 workInProgress로 변경)**

**파이버의 작업 순서**

파이버 작동 흐름을 살펴보자(초기 렌더링, 마운트 단계)

1. 리액트는 beginWork()함수를 실행해 파이버 작업 수행하는데, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식을 시작 , 재귀
2. 1번 작업이 끝난다면 그다음 completeWokr() 함수를 실행해 파이버 작업을 완료한다.
3. 형제가 있따면 형제로 넘어간다.
4. 2, 3번이 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.

루트 노드가 완성되는 순간, 최종적으로 commitWork()가 수행되고 이 중에 변경 사항을 비교해 업데이트가 필요한 변경 사항이 DOM에 반영된다.

가급적 파이버 객체를 새롭게 만들기 보다는 기존에 있는 객체를 재활용하기 위해 내부 속성값만 초기화하거나 바꾸는 형태로 트리를 업데이트한다. 트리가 업데이트 되는 과정은 재귀적으로 처리되어 동기적으로 처리되었다. 하지만 이러한 작업을 파이버 단위로 나눠서 수행한다.

### 파이버와 가상 DOM

리액트 컴포넌트에 대한 정보를 1:1로 가지고 있는 것이 파이버이며, 이 파이버는 리액트 아키텍처 내부에서 비동기로 이뤄진다. 하지만 이 정보들을 실제 브라우저 DOM에 반영하는 것은 동기적으로 일어나야 하고, 또 처리하는 작업이 많아 여러 작업을 가상에서, 즉 메모리 상에서 먼저 수행해 최종적인 결과물만 실제 브라우저 DOM에 적용한다.

가상 DOM은 엄밀히 말하면 이는 오직 웹 애플리케이션에서만 통용되는 것이다. 파이버와 가상 DOM은 동일한 개념이 아니다.

**정리**

가상 DOM은 개발자가 직접 DOM을 수동으로 하나하나 변경해야 한다면 어떤 값이 바뀌었는지, 또 그 값에 따라 어떠한 값이 변경됐는지 이와 관련된 것들이 무엇인지 파악하는 어려움에서 도움을 주는 개념이다.

가상 DOM을 구현하기 위해 파이버의 개념과 이를 조정하는 재조정자가 만들어진것이다. 리액트 내부의 파이버와 재조정자가 내부적인 알고리즘을 통해 관리해 대규모 웹 애플리케이션을 효율적으로 유지보수하고 관리할 수 있게 된것이다.

가상 DOM은 값으로 UI를 표현하는 것이다. 그리고 이러한 값의 흐름을 효율적으로 관리하기 위한 메커니즘이 바로 리액트의 핵심이다. 

## 클래스형 컴포넌트와 함수형 컴포넌트

보일러 플레이트: 반복적으로 비슷한 형태를 갖는 코드

### 클래스형 컴포넌트

클래스형 컴포넌트를 사용하면서 가장 자주 언급되는 것이 바로 생명주기다.

- 마운트: 컴포넌트가 마운트(생성)되는 시점
- 업데이트: 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
- 언마운트: 컴포넌트가 더 이상 존재하지 않는 시점

getSnapshotBeforeUpdate, getDerivedStateFromError, componentDidCatch 이 세가지 메서드가 필요한 경우라면 클래스형 컴포넌트를 사용해야 한다. 아직 훅으로 구현되어 있지 않다.

- getSnapshotBeforeUpdate: DOM이 업데이트되기 직전에 호출된다.
- getDerivedStateFromError: 자식 컴포넌트에서 에러가 발생했을 경우 호출되는 메서드
- componentDidCatch: 자식 컴포넌트에서 에러가 발생했을 때 실행되며 getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행된다. 에러 발생시 에러 정보를 바탕으로 로깅하는 등의 용도로 사용할 수 있다.

**클래스형 컴포넌트의 한계**

- 데이터 흐름을 추적하기 어렵다
    - state의 흐름을 추적하기 어렵다. 생명주기 메서드, 클래스 내부 메서드 등 여러 곳에서 상태 업데이트가 일어날 수 있고 메서드의 실행 순서가 강제돼 있는게 아니므로 사람이 읽기 매우 어렵다.
- 애플리케이션 내부 로직 재사용이 어렵다
    - 컴포넌트 간의 중복되는 로직이 있어 재사용하고 싶은 경우 또 다른 고차 컴포넌트로 감싸거나 props로 넘겨주는 방식으로 공유해야 한다. 하지만 공통 로직이 많아지는 경우 고차 컴포넌트, props가 많아지는 래퍼 지옥에 빠젿르 위험성이 커진다. 이는 애플리케이션 규모가 커지면 커질수록 어려워진다.
- 클래스는 함수에 비해 어렵다
    - 자바스크립트 환경에서 함수에 비해 클래스의 사용이 비교적 어렵고 일반적이지 않다. 대부분 언어에서 동작하는 this와 자바스크립트의 this도 동작이 다르고… 이런 점 때문에 어려움을 느낄 수 있다.
    

이 밖에도 최적화에도 클래스형 컴포넌트는 한계점이 있고, 이런 문제점들을 극복하기 위해 리액트는 기존의 무상태 컴포넌트였던 함수형 컴포넌트에 **상태를 더할 수 있는 훅**을 출시해 함수형 컴포넌트를 많은 사람들이 사용하게끔 유도한다.

### 함수형 컴포넌트

this 바인딩을 조심할 필요도 없으며, state는 객체가 아닌 각각의 원시값으로 관리되어 훨씬 사용하기가 편해졌다. (객체로도 사용할 수 있다)

### 함수형 컴포넌트 vs 클래스형 컴포넌트

**생명주기 메서드의 부재**

가장 눈에 띄는 부분은 생명주기 메서드가 함수형 컴포넌트에서 사용되지 않는다는 것이다. 함수형 컴포넌트는 props를 받아 단순히 리액트 요소만 반환하는 함수인 반면, 클래스형 컴포넌트는 React.Component를 상속받아 사용하는 자바스크립트 클래스이기 때문이다. useEffect를 이용해 언급했던 생명주기 메서드를 비슷하게 구현할 수 있다. 하지만 useEffect는 생명주기를 위한 훅이 아니라 컴포넌트의 state를 활용해 동기적으로 부수효과를 만드는 메커니즘이다.

**함수형 컴포넌트와 렌더링 된 값**

함수형 컴포넌트는 렌더링 된 값을 고정하고, 클래스형 컴포넌트는 그렇지 못한다.

클래스형 컴포넌트에서 props는 this를 이용해 접근하는 반면 함수형 컴포넌트는 props를 인수로 받는다. this와 달리 인수로 받기 때문에 컴포넌트는 그 값을 변경할 수 없고 해당 값을 그대로 사용하게 된다.

**클래스형 컴포넌트를 공부해야 할까?**

자식 컴포넌트에서 발생한 에러를 처리하기 위해서는 클래스형 컴포넌트를 알아야 한다.

## 렌더링은 어떻게 일어나는가?

브라우저에서의 렌더링은 HTML과 CSS 리소스를 기반으로 웹페이지에 필요한 UI를 그리는 과정을 의미한다.

리액트에서 렌더링은 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정을 의미한다.

### 리액트의 렌더링이란?

리액트의 렌더링과 브라우저의 렌더링은 차이가 있다. 

리액트에서 렌더링이란 

리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.

### 리액트의 렌더링이 일어나는 이유

리액트에서 렌더링이 발생하는 시나리오는 다음과 같다.

1. 최초 렌더링: 사용자가 처음 애플리케이션에 진입했을 때, 리액트는 브라우저가 렌더링 할 결과물을 제공하기 위해 최초 렌더링을 수행한다.
2. 리렌더링: 리렌더링은 최초 발생한 렌더링 이후로 발생하는 모든 렌더링을 의미한다.
    1. 클래스형 컴포넌트 setState, forceUpdate(강제 리렌더링)
    2. 함수형 컴포넌트 useState의 setter 함수, useReducer의 dispatch 함수 실행
    3. 컴포넌트의 key props가 변경
        1. 리액트에서 key는 리렌더링이 발생하는 동안 형제 요소들 사이에서 동일한 요소를 식별하는 값
        2. key를 이용해 상태값이 변경되지 않아도 강제 리렌더링이 가능하다.
    4. props가 변경되는 경우
    5. 부모 컴포넌트가 렌더링될 경우: 부모 컴포넌트가 리렌더링 된다면 자식 컴포넌트 역시 무조건 리렌더링 된다.

### 리액트의 렌더링 프로세스

렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다. 업데이트가 필요하다고 지정돼 있는 컴포넌트를 발견하면 클래스 컴포넌트는 render 함수, 함수형 컴포넌트는 그 자체를 호출한 뒤 결과물을 저장한다.

렌더링 결과물은 JSX 문법으로 구성돼 있고, createElement를 호출해 객체로 변환한다. 렌더링 프로세스가 실행되면서 각 컴포넌트의 렌더링 결과물(객체)을 수집한 다음, 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항 역시 차례차례 수집한다. (Reconciliation)

이런 재조정 과정이 끝나면 모든 변경사항을 하나의 동기 시퀀스로 DOM에 적용해 변경된 결과물을 보이게 된다.

### 렌더와 커밋

렌더 단계는 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 말한다. 비교작업을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계다. 크게 type, props, key를 비교한다.

그 다음으로 커밋 단계는 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정을 말한다. 이 단계가 끝나야 비로소 브라우저의 렌더링이 발생한다.

리액트가 먼저 DOM을 커밋 단계에서 업데이트한다면 모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트한다. 그 다음, 클래스형 컴포넌트에서는 componentDidMount, componentDidUpdate 메서드를 호출하고, 함수형 컴포넌트에서는 useLayoutEffect 훅을 호출한다.

하지만 리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니고, 렌더링을 수행했으나 커밋 단계까지 갈 필요가 없다면 (변경 사항이 없다면) 커밋 단계는 생략될 수 있다.

### 일반적인 렌더링 시나리오 살펴보기

1. 컴포넌트의 setState가 호출된다. (렌더링 트리거)
2. setState가 호출된 컴포넌트의 리렌더링 작업이 렌더링 큐에 들어간다.
3. 리액트는 트리 최상단에서부터 렌더링 경로를 검사한다.
4. 렌더링이 필요한 컴포넌트로 표시되지 않은 컴포넌트는 별다른 작업을 하지 않는다.
5. 업데이트가 필요하다고 체크된 컴포넌트를 리렌더링 한다.
6. 만약 자식 컴포넌트가 있다면 렌더링한다.

## 메모이제이션

리액트에는 useMemo, useCallback, memo와 같은 리액트 렌더링을 최소한으로 줄이기 위한 API가 제공된다. 이러한 메모이제이션 최적화에 대한 오랜 논쟁이 이어지고 있다.

### 꼭 필요한 곳에만 메모이제이션

메모이제이션 역시 비용이 든다. 만약 정말 간단한 작업조차 모두 메모이제이션을 진행한다면 오히려 독이 될 수 있다. 리액트에서 모든 컴포넌트를 memo로 감싸지 않고 개발자에게 선택권을 준것은 메모제이션이 만능이 아니라는 사실을 방증한다.

렌더링도 비용이지만 메모리에 저장하는 것 역시 비용이다. 

### 모두 메모이제이션

잘못된 memo로 지불해야 하는 비용은 props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용이다. 하지만 이는 리액트에 기본적인 재조정 알고리즘에서 일어나는 일이기때문에, props가 복잡해진다면 무시할 수는 없지만 memo를 진행하지 않았을 경우 발생할 수 있는 문제는 아래와 같다

1. 렌더링 비용
2. 렌더링에 따른 컴포넌트 내부 복잡한 로직의 재실행
3. 이 두 가지가 모든 자식 컴포넌트에서 일어남
4. 리액트의 비교 작업

### 결론

리액트를 이해하기 위해 아직 시간이 많다면 어느 시점에서 성능상 이점을 누릴 수 있는지 살펴보는 방식으로 메모지에이션 적용해보기

실제 웹 애플리케이션 성능에 어떠한 영향을 미치는지 비교하면서 확인하기