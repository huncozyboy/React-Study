# 4장 서버 사이드 렌더링

## 서버 사이드 렌더링이란?

최근 각광받고 있는 방식으로, 싱글 페이지 애플리케이션, 과거 방식과 비교, 장점과 단점들과 함께 공부해보려고 한다

### 싱글 페이지 애플리케이션

싱글 페이지 애플리케이션이란 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식을 의미한다.
 최초 첫 페이지에 데이터를 모두 불러온 이후 페이지 전환을 위한 작업이 자바스크립트와 브라우저 history.pushState와 history.replaceState로 이뤄지기 때문에 페이지를 불러온 이후에는 새로운 HTML을 받지 않고 하나의 페이지에서 모든 작업을 처리한다.

- 특징  
1. <body> 내부에 아무런 내용이없음   
2. 사이트 렌더링에 필요한 내부 내용을 자바스크립트 코드로 삽입한 이후 렌더링(즉, 최초 서버에서 최소한의 데이터를 불러온 이후부터는 이미 가지고 있는 자바스크립트 리소스와 브라우저 API를 기반으로 모든 작동이 이뤄짐) 
3. 초기에 로딩해야 할 자바스크립트 리소스가 커지는 단점
4. 로딩된 이후에는 서버를 거쳐 필요한 리소스를 받아올 일이 적어지기 때문에 UX 측면에서 장점이 있다  

**과거 방식과 비교**

- 과거 서버 사이드에서 작동하던 전통적인 방식의 애플리케이션 방식 :    
페이지를 전환할 때마다 새롭게 서버에 페이지를 요청하고 HTML을 다운로드해 파싱하는 작업을 거친다. 이 과정에서 페이지를 새로 그려야 하기 때문에 깜빡임을 보게된다.

- 개선점 :  
페이지 전환을 모두 자바스크립트로 한하여 최초 한 번의 모든 리소스를 다운로드하고 나고, 페이지를 전환할 때 추가 적인 리소스 다운로드 시간이 절약됨, 그리고 경우에 따라서는 페이지를 완전히 새로그리는 것이 아니라 일부만 변경하므로 더욱 매끄럽게 동작한다.

**싱글 페이지 렌더링 방식의 유행 + JAM 스택**

싱글 페이지 애플리케이션은 단지 브라우저 내부에서 작동하는 자바스크립트만 잘 작성하면 문제 발생을 최소화 할 수 있어서, 프론트엔드 개발자들에게 좀 더 간편한 개발 경험을 제공했고 더욱 간편하게 애플리케이션을 개발할 수 있었다.

이러한 시대 상황을 반영해 JAM(JavaSript, API, Markup) 스택이 등장했다. 대부분의 작업을 자바스크립트에서 수행할 수 있기 때문에 HTML, CSS, JS를 미리 빌드해 두고 정적으로 사용자에게 제공했다. 이후 작동은 모두 사용자와 클라이언트에서 실행되므로 서버 확장성 문제에서 좀 더 자유로워질 수 있게 되었다.

**새로운 패러다임의 웹서비스를 향한 요구**

1. 자바스크립트의 규모가 커짐  
2. 자바스크립트 리소스가 거대해짐 
3. 애플리케이션에서 제공하는 자바스크립트 리소스의 크기와 수가 모두 증가
4. 스크립트가 페이지당 소비하는 CPU 시간이 증가
5. 웹 페이지 로딩 시간이 늘어나 사용자의 첫 인터랙션까지 소요되는 시간 증가 

> 웹 서비스의 사용자들은 생각보다 많은 시간을 웹 사이트 로딩에 소비해야 한다. 웹 사이트 방문자들은 그렇게 너그럽지 않기에 개발자들은 제품의 웹 서비스 환경에 대해 고민해야 할 때가 온것이다.

### 서버 사이드 렌더링

서버 사이드 렌더링은 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식이다. 앞서 언급한 싱글 페이지 애플리케이션, 클라이언트 사이드 렌더링 방식의 한계를 개선하고자 서버에서 페이지를 렌더링해 제공하는 기존 방식의 웹 개발이 다시금 떠오르고 있다.

즉, 싱글 페이지 애플리케이션과 서버에서 페이지를 빌드하는 서버 사이드 렌더링의 차이는 웹 페이지 렌더링의 책임을 어디에 두느냐에 차이다.

**장점**

1. 최초 페이지 진입이 비교적 빠르다 (First  Contentful Paint)
    - 싱글 페이지 애플리케이션이라면 사용자가 해당 페이지에 진입하고, 자바스크립트 리소스를 다운로드하고, HTTP 요청을 수행한 이후 이 응답의 결과를 바탕으로 화면을 렌더링한다.
    - 이러한 작업이 서버에서 이뤄진담녀 한결 빠르게 렌더링 될 수 있다.
    - 화면 렌더링이 HTTP 요청에 의존적이거나 렌더링해야 할 HTML의 크기가 커진다면 상대적으로 서버 사이드 렌더링이 더 빠를 수 있다.
    - 그러나 서버가 사용자 트래픽을 감당하지 못하고 리소스를 확보하기 어렵다면 오히려 더 느릴 수 있다.
2. 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다
    - 검색 엔진 봇은 페이지에 진입하고 HTML을 바탕으로 메이지의 검색 정보를 가져오고 이를 바탕으로 검색 엔진에 저장한다.
    - 검색 엔진의 페이지 방문과 사용자 브라우저를 이용한 페이지 방문의 가장 큰 차이는 자바스크립트의 실행 여부이다. 브라우저는 HTML이나 각종 정보로 제공하기 위해 자바스크립트를 실행해야 하지만 로봇은 페이지의 정적인 정보만을 취급한다.
    - 검색 엔진이 페이지를 최초 방문했을 때, 메타 데이터를 제공할 수 없다면 검색 엔진에 불이익이 있을 수 있다.
    - 서버 사이드 렌더링은 최초 렌더링 작업이 서버에서 일어나 HTML응답으로 검색 엔진 봇에 제공할 수 있으므로 검색 엔진 최적화에 대응하기 용이하다.
3. 누적 레이아웃 이동이 적다
    - 누적 레이아웃 이동은 사용자에게 페이지를 보여준 후 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥거리는 것과 같은 부정적인 현상을 의미한다.
    - 싱글 페이지 애플리케이션은 페이지 콘텐츠가 API 요청에 의존하고 응답 속도도 제각각이라 이를 적절하게 처리하지 않으면 누적 레이아웃 이동 문제가 발생할 수 있다.
    - 반면 서버 사이드 렌더링은 모든 요청이 완료된 후에 완성된 페이지를 제공하므로 이런 문제에서 비교적 자유롭다.
4. 사용자 디바이스 성능에 비교적 자유롭다
    - 자바스크립트 리소스의 실행은 사용자의 디바이스에만 실행되므로 절대적으로 사용자 디바이스 성능에 의존적이다.
    - 서버 사이드 렌더링을 수행하면 이러한 부담을 서버에 나눌 수 있으므로 사용자 디바이스 성능에서 비교적 자유로워 질 수 있다.
5. 보안에 좀 더 안전하다
    - 애플리케이션의 모든 활동이 브라우저에 노출되므로 항상 보안 문제를 처리해줘야 한다.
    - 서버 사이드 렌더링의 경우 민감한 작업을 서버에서 처리하고 그 결과만 브라우저에 제공한다면 이런 문제를 피할 수 있다.

**단점**

1. 코드를 작성할 때 항상 서버를 고려해야 한다
    - 서버 사이드 렌더링을 적용하기로 결정했다면 코드 전반에 걸쳐 서버 환경에 대한 고려가 필요하다. 그 중 가장 큰 문제가 되는 것이 브라우저 전역 객체인 `window` 혹은, `sessionStorage` 와 같은 브라우저에만 존재하는 요소들이다.
    - 코드에서 window를 사용하고 있고, 이 코드가 만약 서버에서 실행된다면 참조할 수 없게 된다. 그러므로 서버에서도 실행될 가능성이 있는 코드라면 windwo에 대한 접근을 최소화 해야하고 만약 접근해야 한다면 서버 사이드에서 실행되게 만들면 안된다.
    - 클라이언트에서만 실행되는 코드가 많아질수록 서버 사이드 렌더링의 장점을 잃는다.
2. 적절한 서버가 있어야 한다
    - 싱글 페이지 애플리케이션이나 정적인 HTML 페이지만으로 서비스 할 수 있는 경우는 단순히 HTML, CSS, JS 리소스를 다운로드만 할 수 있으면 된다.
    - 그러나 서버 사이드 렌더링은 사용자의 요청을 받아 렌더링을 수행할 서버가 필요한데 적절한 서버를 구축하는 것은 정말 힘든일이다.
3. 서비스 지연
    - 서버 사이드 렌더링에서 지연이 일어난다면, 특히 최초 로딩인 경우에 사용자에게 렌더링이 끝날 때 까지 어떠한 정보도 제공할 수 없다

### SPA와 SSR을 모두 알아야 하는 이유

그 어떠한 기법도 만능이 아니다. 잘못된 웹 페이지 설계는 성능을 해칠 뿐만 아니라 눈에 띄는 성능 개선도 얻지 못하고 클라이언트, 서버의 작업이 오히려 늘어나기만 하는 역효과를 낳을 수도 있다. 웹 페이지에서 사용자에게 제공하고 싶은 정보는 무엇인지, 어떤 우선순위에 따라 페이지의 내용을 보여줄지를 잘 설계하는 것이 중요하다.

결국 앞의 두 방법론이 모두 상황에 따라 유효한 방법이라는 것을 먼저 이해해야 한다. 두 가지 모두 장단점이 있으며 어느 하나가 완벽하다고 볼 수 없다. 

현대의 서버 사이드 렌더링은 지금까지 봤던 서버 사이드 렌더링 방식과는 조금 다르다. 모든 페이지 빌드를 서버에서 렌더링해 조기 페이지 진입을 빠르게 하는 서버 사이드의 장점을 갖춘 상태로 라우팅 단계에서는 서버에서 내려 받은 자바스크립트를 바탕으로 마치 싱글 페이지 애플리케이션 처럼 작동한다. 이러한 라우팅과 렌더링 방식을 이해하지 못한다면 잘못된 웹 서비스를 만들어 버릴 수도 있다. 따라서 서버에서의 렌더링, 클라이언트에서의 렌더링을 모두 이해해야 두 가지 장점을 완벽하게 취하는 제대로 된 웹 서비스를 구축할 수 있다.

## 서버 사이드 렌더링을 위한 리액트 API

기본적으로 리액트는 프론트엔드 라이브러리로 브라우저 자바스크립트 환경에서 렌더링할 수 있는 방법으로 제공하지만 이와 동시에 리액트 애플리케이션을 서버에서 렌더링할 수 있는 API도 제공한다. window에 접근할 수 없는 **Node.js와 같은 서버 환경에서만 실행**할 수 있다. 리액트에서 서버 사이드 렌더링을 실행할 때 사용되는 API는 리액트 저장소의 react-dom/server.js를 확인하면 된다.

ReactDOMServer라는 객체에 정의된 메서드들을 알아보자.

### renderToString

인수로 넘겨 받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 변환하는 함수다.

```jsx
const result = ReactDOMServer.renderToString(
	React.createElement('div', { id: 'root' }, <SampleComponent />),
);
```

위 코드의 결과는 다음과 같은 문자열이다.

```html
<div id="root" data-reactroot="">
	<div>hello</div>
	<ul>
		<li>apple</li>
		<li>banana</li>
		<li>peach</li>
	</ul>
</div>
```

실제 브라우저가 그려야 할 HTML 결과이다. `<SampleComponent>` 는 일반적인 리액트 컴포넌트이고, `ReactDOMServer.renderToString` 를 바탕으로 리액트 컴포넌트를 렌더링하고 그 결과로 완성된 HTML이 반환된 모습이다.

리액트 훅, 이벤트 핸들러는 결과물에 포함하지 않았고 HTML만을 제공했다. 즉, 클라이언트에서 실행되는 자바스크립트 코드를 포함시키거나 렌더링하는 역할까지 해주지 않는다. 

클라이언트 사이드에서 HTML을 만들지 않고 일단 먼저 완성된 HTML을 제공할 수 있으므로 초기 렌더링에서 좋은 성능을 보일 것이다. 또한 검색을 위한 메타 정보도 미리 준비할 수 있기 때문에 SEO관점에서도 이점이 있다.

여기서 한 가지 중요한 사실은 리액트의 서버 사이드 렌더링은 단순히 최초 HTML 페이지를 빠르게 그리는데 목적이 있다. HTML을 빨리 그리는 대신 클라이언트 단에서 처리하던 훅과 같은 기능은 사용할 수 없고 이와 관련된 별도의 자바스크립트 코드를 모두 다운로드, 파싱, 실행해야 한다.

마지막으로 div#root 요소에는 `data-reactroot` 속성이 존재하는데 리액트 컴포넌트의 루트 엘리먼트가 무엇읹 식별하는 역할을 한다.

### renderToStaticMarkup

renderToString과 아주 유사한 함수다. 이 함수 역시 리액트 컴포넌트를 바탕으로 HTML 문자열을 만들어내는데 리액트에서만 사용하는 추가적인 HTML 속성을 만들어 내지 않는다.

```html
<div id="root">
	<div>hello</div>
	<ul>
		<li>apple</li>
		<li>banana</li>
		<li>peach</li>
	</ul>
</div>
```

같은 코드를 실행했을 때, `data-reactroot` 속성이 추가되지 않은채로 결과물이 반환된 것을 확인할 수 있다. 이함수로 받은 HTML 역시 리액트에서 정의된 훅, 이벤트 리스너가 포함되어 있지않다. 즉, `renderToStaticMarkup`은 리액트의 이벤트 리스너가 필요 없는 완전히 순수한 HTML을 만들 때만 사용된다.

### renderToNodeStream

`renderToNodeStream` 의 결과물은 `renderToString` 의 결과물과 완전히 동일하지만 오직 Node.js 서버에서만 동작할 수 있다. (사실 서버 API를 브라우저에서 사용할 필요가 없다.)

그리고 반환 값의 타입이 문자열이 아니고 Node.js의 ReadableStream이다. ReadableStream은 utf-8로 인코딩된 바이트 스트림으로 Node.js 환경에서만 사용할 수 있다. 클라이언트로 전달하기 위해  문자열로 변환하는 추가적인 작업이 필요하다.

결국 `renderToString` 과 동일한 결과물을 전달하는데 Node.js환경에서 추가적으로 데이터 형식을 변환하는 작업이 필요한데 왜 필요한 것일까? 스트림은 큰 데이터를 다룰 때 데이터를 작은 단위로 분할해 조금씩 처리한다.

생성되는 HTML 결과물의 크기가 작다면 한 번에 생성하든 스트림으로 처리하든 차이가 크지 않을 것이다. 그러나 HTML의 크기가 매우 크다면 이를 문자열로 한 번에 메모리에 올려두고 응답을 수행해야 해서 Node.js 서버에 큰 부담이 될 수 있다. 이를 스트림으로 처리해 큰 크기의 데이터를 분리하여 순차적으로 처리할 수 있다.

만약 스트림 대신 문자열로 처리했다면 HTTP 응답은 거대한 HTML 파일이 완성될 때 까지 기다려야 할 것이다. 이를 스트림을 활용해 서버의 부담을 줄일 수 있다. 이 때문에 대부분 널리 알려진 리액트 서버 사이드 렌더링 프레임워크는 모두 `renderToNodeStream` 을 사용한다.

### renderToStaticNodeStream

renderToNodeStream의 결과물과 동일하나 리액트 자바스크립트에 필요한 리액트 속성이 제공되지 않는다. 순수한 HTML을 스트림으로 전달하는 메서드다.

### hydrate

hydrate 함수는 앞서 살펴본 두개의 함수 `renderToString` 과 `renderToNodeStream` 으로 생성된 HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할을 한다.

이와 비슷하게 브라우저에서 사용되는 `render` 라는 메서드가 있다. render 함수는 컴포넌트와 HTML 요소를 인수로 받는다. 전달된 HTML요소에 해당 컴포넌트를 렌더링하며, 여기에 이벤트 핸들러를 붙이는 작업까지 모두 한 번에 수행한다. render는 클라이언트에섬ㄴ 실행되는, 렌더링과 이벤트 핸들러 추가 등 리액트를 기반으로 한 온전한 웹페이지를 만드는 데 필요한 모든 작업을 수행한다.

`hydrate`는 render와 인수를 넘기는 것이 거의 비슷하다.

```jsx
import ReactDOM from 'react-dom';
import App from './App';

const element = document.getElementById(containerId);
// containerId를 가리키는 element는 서버에서 렌더링된 HTML의 특정 위치를 의미한다.

ReactDOM.hydrate(<App />, element);
```

render와의 점은 기본적으로 이미 렌더링된 HTML이 있다는 가정하에 작업이 수행되고, 렌더링된 HTML을 기준으로 이벤트를 붙이는 작업만 실행한다는 것이다. 그렇다면 만약 리액트 관련 정보가 없는 순수한 HTML 정보를 넘기면 어떻게 될까?

또한 hydrate는 render와 달리 인수로 넘긴 컴포넌트를 렌더링한 정보가 이미 포함돼 있어야 실행할 수 있다. 따라서 인수로 넘겨준 `element` 에는 렌더링된 정적인 HTML 정보가 반드시 담겨 있어야한다.

비록 서버에서 렌더링한 정보가 없더라고 hydrate 작업이 단순히 이벤트나 핸들러를 추가하는 것 외에도 렌더링을 한 번 수행하면서 인수로 전달받은 렌더링 결과물과 실제 렌더링된 결과물을 비교하는 작업을 수행하기 때문이다. 이는 사실상 서버와 클리아인트에서 두 번 렌더링을 하게 되고, 결국 서버 사이트 렌더링의 장점을 포기하게 되는 것이므로 신경써야한다.

## 간단한 SSR 예제

먼저 우리가 사용하는 대부분의 애플리케이션에는 자바스크립트 이벤트 핸들러가 필요하므로 정적인 HTML 결과물을 반환하는 API를 제외하고 , `renderToString`, `renderToNodeStream` 을 기준으로 어떻게 리액트에서 서버 사이드 렌더링이 제공되는지 알아보자.

- index.tsx
    
    ```jsx
    import { hydrate } from 'react-dom';
    
    import App from './compnents/App';
    import { fetchTodo } from './fetch';
    
    async function main() {
    	const result = await fetchTodo();
    
    	const app = <App todos={result} />;
    	const el = document.getElementById('root');
    
    	hydrate(app, el);
    }
    
    main();
    ```
    
    이 파일의 목적은 서버로부터 받은 HTML을 hydrate를 통해 완성된 웹 애플리케이션으로 만드는 것이다. 눈에 띄는 점은 API 요청의 결과를 데이터로 주입한다는 것이다. hydrate는 서버에서 완성한 HTML과 하이드레이션 대상이되는 HTML의 결과물이 동일한지 비교하는 작업을 거치므로 한 번 더 데이터를 조회한다.
    
- index.html
    
    ```jsx
    <!DOCTYPE html>
    <html>
    	<head>
    		<meta charset="utf-8" />
    		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
    		<title>SSR Example</title>
    	</head>
    	<body>
    		__placeholder__
    		<script src="@ulr/react.development.js"></script>
    		<script src="@ulr/react-dom.development.js"></script>
    		<script src="/browser"></script>
    	</body>
    </html>
    ```
    
    서버 사이드 렌더링을 수행할 때 기본이 되는 HTML 템플릿이다. 다만 여기에는 일반적인 HTML과 다른 몇 가지 주목할 포인트가 눈에 띈다.
    
    - `__placeholder__` : 서버에서 리액트 컴포넌트를 기반을 만든 HTML 코드를 삽입하는 자리다. 단순히 이 부분을 결과물로 대체해서 리액트에서 만든 HTML로 대체할 것이다. 물론 리액트 서버 사이드 프레임워크에서는 이렇게 단순한 방식으로 처리하지 않는다.
    - browser.js는 클라이언트 리액트 애플리케이션 코드를 번들링했을 때 제공되는 리액트 자바스크립트 코드다. 즉, __placehoder__에 먼저 HTML 코드가 붙은 후 실행되면서 필요한 자바스크립트 이벤트 핸들러가 붙을 것이다.
- server.ts
    
    다음으로 서버에서 동작하는 파일을 살펴보자. 서버에서는 사용자의 요청에 따라 어떠한 리소스를 내려줄지 결정하는 역할을 한다. 특히 서버 사이드 렌더링을 위해 이 파일에서 리액트 트리를 만드는 역할도 담당하게 된다.
    
    - createServer
        
        http 모듈을 이용해 간단한 서버를 만들 수 있는 Node.js 기본 라이브러리다. 3000번 포트를 사용하는 HTTP 서버를 만든것과 비슷하다.
        
    
    ```jsx
    function main(){
    	createServer(serverHanler).listen(PORT, () => {
    		console.log(`Server has been started ${PORT}...`);
    	});
    }
    ```
    
    - serverHandler
        
        createServer로 넘겨주는 인수로, HTTP 서버가 라우트(주소)별로 어떻게 작동할지를 정의하는 함수다.
        
        ```jsx
        async function serverHandler(req: IncomingMessage, res: ServerResponse) {
        	const { url } = req;
        	
        	switch (url){
        		// ...
        		default: {
        			res.statusCode = 404;
        			res.end('404 Not Found');
        		}
        	}
        }
        ```
        
        각 url을 통해 사용자가 접근한 주소 별로 어떻게 작동할지 정의할 수 있다. 예를 들어 루트 라우터에 접근했다면 createElement를 이용해 자바스크립트 UI 객체를 만들고 응답할 수 있다. 브라우저에 제공되는 리액트 코드를 삽입할 수도 있다.
        

이 내용들만 봐도 서버 사이드 렌더링은 역시 서버에서 다뤄야 할 작업들이 정말 많다. 어느정도 성능을 보장하는 서버 사이드 렌더링을 수행하려면 매우 복잡한 코드가 필요하며, 이를 매번 개발자 개인이 작성하는 것은 매우 비효율 적이다. 또한 서버에서 HTML을 제공하는 것 뿐만 아니라 번들링된 자바스크립트 소스도 제공해야 하며, 적절하게 캐시도 사용해야 하는 등 많은 것들을 고려해야 한다.

더욱이 suspense나 concurrent, 서버 사이트 렌더링과 약간 다른 Server Component 등의 새로운 개념이 추가되면서 서버에서 렌더링 하는 것이 더욱 복잡해졌다.

**Next**

## Next.js 톺아보기

리액트 서버 사이드 렌더링을 기반으로 작성된 프레임워크다. 리액트만으로 웹사이트를 구축하는 데 많은 노력이 필요한 것과 마찬가지로, 아무것도 없는 상태에서 서버 사이드 렌더링까지 지원하는 리액트 애플리케이션까지 만드는 데는 많은 노력을 필요로 하며, 리액트 팀에서도 권장하지 않는 작업이다. 

Next.js는 Vercel이라는 미국 스타트업에서 만든 리액트 기반 서버 사이드 렌더링 프레임워크다.

**서버 라우팅과 클라이언트 라우팅의 차이**

Next.js는 서버 사이드 렌더링을 수행하지만 동시에 싱클 페이지 애플리케이션과 같이 클라잉너트 라우팅 또한 수행한다. <a> 태그로 페이지를 이동하면 모든 리소스를 처음부터 다시 받는다. 반면 Link로 페이지를 이동하면 해당 페이지에만 필요한 내용만 다운로드 받는다. 이 경우 서버 사이드 렌더링이 아닌, 클라이언트에서 필요한 자바스크립트만 불러온 뒤 라우팅하는 클라이언트 라우팅/렌더링 방식으로 작동하는 것을 볼 수 있다. 

Next.js는 사용자에게 최초 페이지를 빠르게 보여줄 수 있는 서버 사이드 렌더링의 장점과 자연스러운 라우팅을 통해 클라이언트 사이드 렌더링의 장점까지 살리기 위해 이런식으로 동작한다.

### Date Fetching

Next.js에서는 서버 사이드 렌더링 지원을 위한 몇 가지 데이터 불러오기 전략이 있는데, 이를 Date fetaching이라고 한다. 이를 활용하면 서버에서 미리 페이지를 만들어서 제공할 수 있다. 이를 활용하면 서버에서 미리 필요한 페이지를 만들어서 제공하거나 해당 페이지에 요청이 있을 때마다 서버에서 데이터를 조회해서 **미리 페이지를 만들어서 제공**할 수 있다.

- **getStaticPaths, getStaticProps**
    
    두 함수는 사용자와 관계없이 정적인 페이지를 보여주고자 할 때 사용되는 함수다. 두 함수는 반드시 같이 사용되어야 한다.
    
    - getStaticPaths는 접근 가능한 주소를 정의하는 함수다. 해당 페이지에서 접근 가능한 페이지를 정의할 수 있다.
    - getStaticProps는 앞에서 정의한 페이지를 기준으로 해당 페이지로 요청이 왔을 때 제공할 props(properties)를 반하는 함수다.
    - 이렇게 반환된 props를 바탕으로 렌더링을 하는 컴포넌트를 만들 수 있다. 즉, 이 두 함수를 사용하면 빌드 시점에 미리 데이터를 불러온 다음에 정적인 HTML 페이지를 만들 수 있다. 사용자가 접근할 수 있는 페이지를 모두 빌드해 두고 배포하면 사용자는 굳이 페이지가 렌더링 되는 것을 기다릴 필요 없이 이미 완성돼 있는 페이지를 받기만 하면 되므로 굉장히 빠르게 페이지를 확인할 수 있다.
    - 정적인 데이터만 제공하면 되는 사이트에서 유용하게 사용할 수 있다
- **getServerSideProps**
    
    서버에서 실행되는 함수이며 해당 함수가 있다면 무조건 페이지 진입 전에 이 함수를 실행한다. 이 함수는 응답 값에 따라 페이지의 루트 컴포넌트에 props를 반환할 수도, 혹은 다른 페이지로 리다이렉트 시킬 수도 있다.
    
    즉, Next.js의 서버 사이드 렌더링은 **`getServerSideProps`** 의 실행과 함께 이뤄지며, 이 정보를 기반으로 페이지를 렌더링하는 과정이 서버 사이드 렌더링을 나타내는 것임을 알 수 있다.
    
    리액트의 서버 사이드 렌더링을 하는 작동
    
    1. 서버에서 fetch 등으로 렌더링에 필요한 정보를 가져온다
    2. 1번에서 가져온 정보를 바탕으로 HTML을 완성한다.
    3. 2번의 정보를 클라이언트에 제공한다.
    4. 3번의 정보를 바탕으로 클라이언트에서 hydrate 작업을 통해 DOM에 리액트 라이프사이클과 이벤트 핸들러를 추가하는 작업이다.
    5. hydrate로 만든 리액트 컴포넌트 트리와 서버에서 만든 HTML이 다르면 불일치 에러를 뱉는다. 이 작업에서도 역시 fetch 등을 이용해 정보를 가져와야 한다.
    
    이 함수에서 제공하는 값은 JSON 형태로 class와 같은 데이터는 props로 제공할 수 없다. 그리고 서버에서만 실행되는 함수이기 때문에 브라우저 API를 사용할 수 없고, API 호출 시 protocol과 domain없이 fetch를 요청할 수 없다. 브라우저와 다르게 서버는 자신의 호스트를 유추할 수 없기 때문이다. 서버 사이드 렌더링은 클라이언트에서만 실행 가능한 변수, 함수 라이브러리 등은 서버에서 실행되지 않도록 별도로 처리해야한다.
    
    Next에서 서버 사이드 렌더링을 잘 표현하기 위한 핵심 함수이므로 반드시 잘 숙지하자.